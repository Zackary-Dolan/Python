#-------------------------------------
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, accuracy_score
import pandas as pd


class Quali_Machine_Learning:

    def __init__(self, csv_file='qualifying.csv'):
        self.df = pd.read_csv(csv_file)

        for col in ['q1', 'q2', 'q3']:
            self.df[col] = self.df[col].apply(self.lap_to_seconds)

        self.df["Target"] = (self.df["position"] <= 10).astype(int)

        self.feature_columns = ['driverId', 'constructorId', 'number', 'q1', 'q2']
        # self.X = self.df.drop(['Target', 'position'], axis='columns')
        # self.Y = self.df['Target']
        self.X = self.df[self.feature_columns]
        self.Y = self.df['Target']
        self.seedValue = 1

        self.X_train = None
        self.X_test = None
        self.Y_train = None
        self.Y_test = None

        self.tree = DecisionTreeClassifier()
        self.Y_hat = None
        self.cm = None

        print("Target column added and lap times converted.")

    def lap_to_seconds(self, t):#converts the times so they can be used
        if pd.isna(t) or t == '':
            return 0.0
        t = str(t).strip()
        if ':' in t:
            try:
                mins, secs = t.split(':')
                return int(mins) * 60 + float(secs)
            except ValueError:
                return 0.0
        else:
            return float(t)

    def updateSeed(self, newValue):
        self.seedValue = newValue

    def trainData(self, test_fraction=0.2):
        self.X_train, self.X_test, self.Y_train, self.Y_test = train_test_split(
            self.X, self.Y, test_size=test_fraction,
            random_state=self.seedValue, stratify=self.Y
        )

        self.tree.fit(self.X_train, self.Y_train)
        print("Decision Tree trained successfully.")

    def makePrediction(self,driverId, constructorId, number,q1, q2):
        # Convert lap times
        q1 = self.lap_to_seconds(q1)
        q2 = self.lap_to_seconds(q2)
        # q3 = self.lap_to_seconds(q3)

        input_data = [[driverId, constructorId, number, q1, q2]]
        df2 = pd.DataFrame(input_data, columns=['driverId', 'constructorId', 'number', 'q1', 'q2'])

        return self.tree.predict(df2)[0]

    def testData(self):
        self.Y_hat = self.tree.predict(self.X_test)

        accuracy = accuracy_score(self.Y_test, self.Y_hat)
        cm = confusion_matrix(self.Y_test, self.Y_hat)

        print("Accuracy:", accuracy)
        print("Confusion Matrix:\n", cm)

        return cm, accuracy

    def readCategories(self):
        result = ''
        index = 0
        setOfCategories = set(self.Y)
        for catName in sorted(setOfCategories):
            if index > 0:
                result += " / "
            if catName == 0:
                result += "Not top 10"
            if catName == 1:
                result += "Qualified top 10"
            index += 1
        return result

    def get_driver_average_times(self, driverId):
        df_driver = self.df[self.df["driverId"] == driverId]

        if df_driver.empty:
            return None  # driver not found

        avg_q1 = df_driver["q1"].replace(0, pd.NA).mean()
        avg_q2 = df_driver["q2"].replace(0, pd.NA).mean()
        avg_q3 = df_driver["q3"].replace(0, pd.NA).mean()

        return {
            "driverId": driverId,
            "Q1": avg_q1,
            "Q2": avg_q2,
            "Q3": avg_q3
        }
